{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleInstances #-}
import Test.QuickCheck (Gen, elements, Arbitrary, vectorOf)
import Test.QuickCheck.Arbitrary (arbitrary)
{--

-- Question 1 --

i:
filter' :: (a -> Bool) -> [a] -> [a]
filter' f []     = []
filter' f (a:as) | f a = a : filter' f as
                 | otherwise = filter' f as

ii:
-- Det sista elementet i listan är det vi skickar
-- som parameter i den sista foldl-kallet.
-- Parametern vi skickar i kallet är hela tiden resultatet
-- av funktionen g, när den är applicerad på det förra och det nya talet
-- den får (i den ordningen), därmed kastar vi det gamla varje gång
-- och returnerar det nya

g :: a -> a -> a
g _ n = n
        
iii:
lookup :: (Eq a) => a -> [(a,b)] -> Maybe b
lookup key l = listToMaybe $ map snd $ filter (\ (k,v) -> key == k) l

iv:
sequence_ :: Monad m => [m a] -> m ()
sequence_ []     = return ()
sequence_ (a:as) = a >> sequence_ as 

v:
unzip :: [(a,b)] -> ([a],[b])
unzip []            = ([],[])
unzip ((a,b):asnbs) = (a:as, b:bs)
    where 
        (as,bs) = unzip asnbs 

-- Question 2 --
fa :: (Ord a) => a -> a -> Maybe Bool 
fa m n = Just (m > n)

fb :: (Num b) => a -> a -> (a -> b) -> b
fb x y z = z y + z x

fc :: (Eq a) => [[a]] -> [a] -> Bool
fc (x:xs) (y:ys) = x == ys
fc [] ys = null ys

fd :: (Monad m) => m Int -> m [Int] 
fd x = do
    z <- x
    return $ replicate z z

-- Question 3 --
permu :: [a] -> [[a]]
permu [] = [[]]
permu (x:xs) = concatMap (insertAll x) $ permu xs

i:
-- insertAll is mapped onto permu xs, which has the type [[a]].
-- Therefore it takes an element, x, and a list, and returns a matrix.
-- It has to return a matrix since the return type of the function is a matrix,
-- and therefore concat needs a 3d matrix, to turn into a normal matrix

insertAll :: a -> [a] -> [[a]]

ii:
-- Incorrect
insertAll :: a -> [a] -> [[a]]
insertAll x [] = [[x]]
insertAll x (p:ps) = map (x:) (insertAll x ps)

-- Right
insertAll :: a -> [a] -> [[a]]
insertAll x l = [take n l ++ [x] ++ drop n l | n <- [0..length l]]

iii:
prop_permu :: [a] -> Bool
prop_permu as = all (`isPermutationOf` as) (permu as)

-- We need to check that the lists are of equal length,
-- and that every item in the permutation exists in the
-- list.
isPermutationOf :: [a] -> [a] -> Bool
isPermutationOf perm list = length perm == length list &&
                            all (`elem` list) perm 

                            
-- Question 4 --
data T a = Leaf | Node a (T a) (T a)
    deriving Show


extree =                    Node 2
    (Node 1 Leaf Leaf)                 (Node 1
                       (Node 1  Leaf Leaf) (Node 0 Leaf Leaf))

extree' = (Node 2 c1 c2)
    where
        c1 = (Node 1 Leaf Leaf)
        c2 = (Node 1 (Node 1 Leaf Leaf)
                     (Node 0 Leaf Leaf))


parents :: Eq a => a -> T a -> [a]
parents _ Leaf = []
parents x (Node n t1 t2) = if leftStatus || rightStatus
                           then n : (parents x t1 ++ parents x t2)
                           else parents x t1 ++ parents x t2
    where
        leftStatus = childMatches x t1
        rightStatus = childMatches x t2

childMatches :: Eq a => a -> T a -> Bool
childMatches _ Leaf = False
childMatches x (Node n _ _) = x == n


prop_parents :: Eq a => a -> T a -> Bool
prop_parents n t = all (\x -> (x `occurrs` t) /= 0) (parents n t) &&
                   length (parents n t) <= n `occurrs` t


occurrs :: Eq a => a -> T a -> Int
occurrs _ Leaf           = 0
occurrs x (Node n t1 t2) = if x == n then 1 + continue else continue
    where
        continue = occurrs x t1 + occurrs x t2


-- The trees generated by this can have subtrees with  
-- heights of h-1 to h-h, as long as one of them has 
-- n-1 height all the time 
genT :: Int -> [a] -> Gen (T a)
genT h es | h <= 0 = return Leaf
          | otherwise = do
                nv <- elements es
                hd <- elements [1..h]
                hs <- elements [(h-1, h-hd), (h-hd, h-1)]
                t1 <- genT (fst hs) es
                t2 <- genT (snd hs) es
                return $ Node nv t1 t2

-- Just extra stuff
prop_height :: T Int -> Bool
prop_height t = height t <= 4 && height t >= 1

height :: T a -> Int
height Leaf           = 0
height (Node _ t1 t2) = 1 + max (height t1) (height t2)

instance Arbitrary a => Arbitrary (T a) where
    arbitrary = do
        es <- vectorOf 10 arbitrary
        h  <- elements [1..4]
        genT h es

--}
